---
title: Overview. 2.2 Analysis. Properties
category: verification
author: Andrey Sadovykh
layout: page
---

---

## ğŸ” Software Properties Verified by Static Analysis

**Definition:**  
Safety properties ensure thatÂ _nothing bad happens_Â during program execution. These properties guarantee the system doesÂ **not reach an undesirable state**.

**Examples:**

- NoÂ **deadlocks**Â (e.g. multiple processes waiting forever for each other).
    
- No attempt toÂ **access an empty buffer**Â (e.g. removing an item that isnâ€™t there).
    

**Purpose:**  
Used to ensure theÂ **consistency of program state**.

**How?**

- EnforceÂ **mutual exclusion**: Shared resources must be accessed atomically (only one thread/process at a time).
    
- UseÂ **condition synchronization**: Certain actions are delayed until the system is in a safe state.
    

---

### âœ… Liveness Properties

**Definition:**  
Liveness properties ensure thatÂ _something good eventually happens_. They are used to guaranteeÂ **progress**Â in the system.

**Prevents:**

- **Starvation**: A process never gets needed resources (like CPU time).
    
- **Dormancy**: A waiting process is never resumed.
    
- **Premature termination**: A process ends before it should.
    

---

### âš–ï¸ Fairness Properties

**Definition:**  
A subset of liveness properties.Â **Fairness**Â means that every process or action gets its fair shareÂ _infinitely often_.

**Example:**

- A process is guaranteed to be activated repeatedly (e.g. each thread gets a turn in a scheduler).
    

---

### â³ Temporal Properties

**Definition:**  
Temporal properties describe how states are relatedÂ **over time**. UnlikeÂ **state properties**Â (which describe a single point),Â **temporal properties**Â describeÂ **paths or sequences of states**.

**Example:**  
â€œIf a message is sent in one state, it will eventually be received in a future state.â€

**Notation (common temporal logic):**

- **Î±**: Î± holds in the current state
    
- **XÎ±**: Î± holds in theÂ _next_Â state
    
- **FÎ³**: Î³ holdsÂ _eventually_Â (in the future)
    
- **GÎ»**: Î» holdsÂ _always_Â from now on
    
- **Î± U Î²**: Î± holdsÂ _until_Â Î² becomes true
    

---

## ğŸ§° Analysis Fault Taxonomy (Common Issues Detected by Static Analysis)

### ğŸ§µ Concurrency Errors

- **Race conditions**: Multiple threads access shared data unsafely.
    
- **Deadlock**: Processes wait on each other in a cycle.
    
- **Improper lock usage**
    

### âš ï¸ Exceptional Conditions

- Integer overflow/underflow
    
- Division by zero
    
- Unhandled exceptions
    
- Incorrect type conversions
    

### ğŸ›¡ï¸ Input Validation Issues

- **Command injection**
    
- **Cross-site scripting (XSS)**
    
- **Format string vulnerabilities**
    
- Use ofÂ **tainted data**Â (untrusted user input)
    

### ğŸ§¹ Code Quality Issues

- PoorÂ **code metrics**
    
- **Unused variables**
    

### ğŸ’¾ Memory Errors

- **Buffer overruns**
    
- **Null or invalid pointer dereference**
    
- **Double free**Â or freeing unallocated memory
    
- **Memory leaks**
    
- Use ofÂ **uninitialized variables**
    

### ğŸ”„ Resource/Protocol Misuse

- Incorrect function call order
    
- Forgetting to initialize or free resources
    

### ğŸ§  Design & Structural Issues

- ComplexÂ **dependencies**
    
- ComplicatedÂ **heap structures**
    
- Incomplete or messyÂ **call graphs**
    

### ğŸ” Security Weaknesses

- **Privilege escalation**
    
- **Denial of service (DoS)**
    
- Execution ofÂ **dynamic code**
    
- **Insecure randomness**
    
- ViolatingÂ **least privilege principle**
    

---

## ğŸ§ª How does the Analysis work?

**Software analysis**Â involves creating aÂ **model**Â of the system (either manually or automatically), and thenÂ **verifying properties**Â of the system using the modelâ€”**without running**Â the actual software.

> By abstracting away unnecessary details, we can prove or disprove whether certain properties hold.

---

## ğŸ¯ Precision of Static Analysis

- **Soundness**:  
    If the tool says the program isÂ **correct**, it truly is.  
    âœ… No false negatives (i.e. no missed bugs).
    
- **Completeness**:  
    If the tool reports anÂ **issue**, itâ€™s real.  
    âœ… No false positives (i.e. no bogus warnings).
    

> â— In practice,Â **no static analysis can be both sound and complete**Â and stillÂ **terminate**Â on all programs.

### Reality of Static Analysis:

- **Perfect static analysis is undecidable**: itâ€™s impossible to create one that works perfectly for all programs.
    
- All analysesÂ **use abstraction**Â to approximate behavior.
    
- Still, static analysis tools are extremelyÂ **useful in practice**.
    

---

## ğŸ› ï¸ Methods and Approaches

### ğŸ” Static Analysis

- WorksÂ **directly on source code**.
    
- Detects basic but important properties.
    
- Examples:
    
    - `lint`,Â `FindBugs`,Â `SonarQube`,Â `CodeQL`,Â `CodeSense`
        

### ğŸ”„ Model Checking

- Uses aÂ **formal model**Â of the system.
    
- Exhaustively explores all possible states (like brute force).
    
- MostlyÂ **automated**, but model creation is manual.
    
- Example:Â **SPIN**
    

### ğŸ§  Theorem Proving

- Uses mathematical logic toÂ **prove correctness**.
    
- RequiresÂ **expert human guidance**.
    
- Suitable for very critical systems.
    
- Examples:Â **PVS**,Â **ESC/Java**
    

---


## ğŸ”§ Modern Theorem Proving Tools for Static Analysis

### 1.Â **Rocq (formerly Coq)**

- **Overview**: Rocq is an interactive theorem prover designed for formalizing mathematical proofs and verifying software correctness. It allows for the development of mathematical proofs and formal specifications, ensuring that programs comply with their specifications.
    
- **Key Features**:
    
    - Supports the calculus of inductive constructions.
        
    - Can extract executable programs from specifications in OCaml or Haskell.
        
    - Includes automatic theorem proving tactics and decision procedures.
        
- **Use Cases**: Formal verification of software, development of certified programs, and educational purposes in formal methods.
    
- **Website**:Â [rocq-prover.org](https://rocq-prover.org/)Â ([Rocq](https://rocq-prover.org/?utm_source=chatgpt.com "Welcome to a World of Rocq"),Â [Wikipedia](https://en.wikipedia.org/wiki/Rocq?utm_source=chatgpt.com "Rocq"))
    

### 2.Â **Isabelle**

- **Overview**: Isabelle is a generic proof assistant that supports various logical formalisms, including higher-order logic. It provides a framework for developing formal proofs and is widely used in academia and industry.
    
- **Key Features**:
    
    - Supports higher-order logic and other formalisms.
        
    - Offers a rich set of tools for proof development and automation.
        
    - Includes the Isabelle Archive of Formal Proofs (AFP) for sharing verified theories.
        
- **Use Cases**: Formal verification of software and hardware systems, mathematical theorem proving, and education in formal methods.
    
- **Website**:Â [isabelle.in.tum.de](https://isabelle.in.tum.de/)Â ([Wikipedia](https://en.wikipedia.org/wiki/Isabelle_%28proof_assistant%29?utm_source=chatgpt.com "Isabelle (proof assistant)"))
    

### 3.Â **KeY**

- **Overview**: KeY is a formal verification tool tailored for Java programs. It uses dynamic logic to specify and verify program properties, allowing for both interactive and automated proofs.
    
- **Key Features**:
    
    - Integrates with Java Modeling Language (JML) for specifying program behavior.
        
    - Supports verification of Java programs through symbolic execution and deductive reasoning.
        
    - Provides a user-friendly interface for proof construction and analysis.
        
- **Use Cases**: Verification of Java applications, ensuring compliance with specifications, and detecting potential bugs or security vulnerabilities.
    
- **Website**:Â [key-project.org](https://www.key-project.org/)Â ([Wikipedia](https://en.wikipedia.org/wiki/KeY?utm_source=chatgpt.com "KeY"))
    

### 4.Â **Z3**

- **Overview**: Z3 is a high-performance theorem prover developed by Microsoft Research. It is used for checking the satisfiability of logical formulas and is widely employed in software verification and analysis.
    
- **Key Features**:
    
    - Supports various theories, including arithmetic, bit-vectors, arrays, and more.
        
    - Provides APIs for multiple programming languages, facilitating integration into different tools.
        
    - Efficiently handles large and complex verification problems.
        
- **Use Cases**: Static analysis, formal verification, constraint solving, and symbolic execution in software development.
    
- **Website**:Â [github.com/Z3Prover/z3](https://github.com/Z3Prover/z3)Â ([Wikipedia](https://en.wikipedia.org/wiki/Z3_Theorem_Prover?utm_source=chatgpt.com "Z3 Theorem Prover"),Â [arXiv](https://arxiv.org/abs/1907.03890?utm_source=chatgpt.com "Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts"))
    

### 5.Â **Frama-C with Jessie Plugin**

- **Overview**: Frama-C is a static analysis framework for C programs. The Jessie plugin within Frama-C allows for deductive verification using formal specifications and theorem proving.
    
- **Key Features**:
    
    - Supports the ANSI/ISO C Specification Language (ACSL) for annotating C code.
        
    - Integrates with various theorem provers like Coq, Z3, and Alt-Ergo for verifying proof obligations.
        
    - Provides a modular architecture with multiple analysis plugins.
        
- **Use Cases**: Formal verification of safety-critical C programs, ensuring adherence to specifications, and detecting potential runtime errors.
    
- **Website**:Â [frama-c.com](https://frama-c.com/)Â ([Wikipedia](https://en.wikipedia.org/wiki/Frama-C?utm_source=chatgpt.com "Frama-C"))
    
