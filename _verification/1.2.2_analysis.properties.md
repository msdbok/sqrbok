---
title: Overview. 2.2 Analysis. Properties
category: verification
author: Andrey Sadovykh
layout: page
---

---

## 🔐 Software Properties Verified by Static Analysis

**Definition:**  
Safety properties ensure that _nothing bad happens_ during program execution. These properties guarantee the system does **not reach an undesirable state**.

**Examples:**

- No **deadlocks** (e.g. multiple processes waiting forever for each other).
    
- No attempt to **access an empty buffer** (e.g. removing an item that isn’t there).
    

**Purpose:**  
Used to ensure the **consistency of program state**.

**How?**

- Enforce **mutual exclusion**: Shared resources must be accessed atomically (only one thread/process at a time).
    
- Use **condition synchronization**: Certain actions are delayed until the system is in a safe state.
    

---

### ✅ Liveness Properties

**Definition:**  
Liveness properties ensure that _something good eventually happens_. They are used to guarantee **progress** in the system.

**Prevents:**

- **Starvation**: A process never gets needed resources (like CPU time).
    
- **Dormancy**: A waiting process is never resumed.
    
- **Premature termination**: A process ends before it should.
    

---

### ⚖️ Fairness Properties

**Definition:**  
A subset of liveness properties. **Fairness** means that every process or action gets its fair share _infinitely often_.

**Example:**

- A process is guaranteed to be activated repeatedly (e.g. each thread gets a turn in a scheduler).
    

---

### ⏳ Temporal Properties

**Definition:**  
Temporal properties describe how states are related **over time**. Unlike **state properties** (which describe a single point), **temporal properties** describe **paths or sequences of states**.

**Example:**  
“If a message is sent in one state, it will eventually be received in a future state.”

**Notation (common temporal logic):**

- **α**: α holds in the current state
    
- **Xα**: α holds in the _next_ state
    
- **Fγ**: γ holds _eventually_ (in the future)
    
- **Gλ**: λ holds _always_ from now on
    
- **α U β**: α holds _until_ β becomes true
    

---

## 🧰 Analysis Fault Taxonomy (Common Issues Detected by Static Analysis)

### 🧵 Concurrency Errors

- **Race conditions**: Multiple threads access shared data unsafely.
    
- **Deadlock**: Processes wait on each other in a cycle.
    
- **Improper lock usage**
    

### ⚠️ Exceptional Conditions

- Integer overflow/underflow
    
- Division by zero
    
- Unhandled exceptions
    
- Incorrect type conversions
    

### 🛡️ Input Validation Issues

- **Command injection**
    
- **Cross-site scripting (XSS)**
    
- **Format string vulnerabilities**
    
- Use of **tainted data** (untrusted user input)
    

### 🧹 Code Quality Issues

- Poor **code metrics**
    
- **Unused variables**
    

### 💾 Memory Errors

- **Buffer overruns**
    
- **Null or invalid pointer dereference**
    
- **Double free** or freeing unallocated memory
    
- **Memory leaks**
    
- Use of **uninitialized variables**
    

### 🔄 Resource/Protocol Misuse

- Incorrect function call order
    
- Forgetting to initialize or free resources
    

### 🧠 Design & Structural Issues

- Complex **dependencies**
    
- Complicated **heap structures**
    
- Incomplete or messy **call graphs**
    

### 🔐 Security Weaknesses

- **Privilege escalation**
    
- **Denial of service (DoS)**
    
- Execution of **dynamic code**
    
- **Insecure randomness**
    
- Violating **least privilege principle**
    

---

## 🧪 How does the Analysis work?

**Software analysis** involves creating a **model** of the system (either manually or automatically), and then **verifying properties** of the system using the model—**without running** the actual software.

> By abstracting away unnecessary details, we can prove or disprove whether certain properties hold.

---

## 🎯 Precision of Static Analysis

- **Soundness**:  
    If the tool says the program is **correct**, it truly is.  
    ✅ No false negatives (i.e. no missed bugs).
    
- **Completeness**:  
    If the tool reports an **issue**, it’s real.  
    ✅ No false positives (i.e. no bogus warnings).
    

> ❗ In practice, **no static analysis can be both sound and complete** and still **terminate** on all programs.

### Reality of Static Analysis:

- **Perfect static analysis is undecidable**: it’s impossible to create one that works perfectly for all programs.
    
- All analyses **use abstraction** to approximate behavior.
    
- Still, static analysis tools are extremely **useful in practice**.
    

---

## 🛠️ Methods and Approaches

### 🔍 Static Analysis

- Works **directly on source code**.
    
- Detects basic but important properties.
    
- Examples:
    
    - `lint`, `FindBugs`, `SonarQube`, `CodeQL`, `CodeSense`
        

### 🔄 Model Checking

- Uses a **formal model** of the system.
    
- Exhaustively explores all possible states (like brute force).
    
- Mostly **automated**, but model creation is manual.
    
- Example: **SPIN**
    

### 🧠 Theorem Proving

- Uses mathematical logic to **prove correctness**.
    
- Requires **expert human guidance**.
    
- Suitable for very critical systems.
    
- Examples: **PVS**, **ESC/Java**
    

---


## 🔧 Modern Theorem Proving Tools for Static Analysis

### 1. **Rocq (formerly Coq)**

- **Overview**: Rocq is an interactive theorem prover designed for formalizing mathematical proofs and verifying software correctness. It allows for the development of mathematical proofs and formal specifications, ensuring that programs comply with their specifications.
    
- **Key Features**:
    
    - Supports the calculus of inductive constructions.
        
    - Can extract executable programs from specifications in OCaml or Haskell.
        
    - Includes automatic theorem proving tactics and decision procedures.
        
- **Use Cases**: Formal verification of software, development of certified programs, and educational purposes in formal methods.
    
- **Website**: [rocq-prover.org](https://rocq-prover.org/) ([Rocq](https://rocq-prover.org/?utm_source=chatgpt.com "Welcome to a World of Rocq"), [Wikipedia](https://en.wikipedia.org/wiki/Rocq?utm_source=chatgpt.com "Rocq"))
    

### 2. **Isabelle**

- **Overview**: Isabelle is a generic proof assistant that supports various logical formalisms, including higher-order logic. It provides a framework for developing formal proofs and is widely used in academia and industry.
    
- **Key Features**:
    
    - Supports higher-order logic and other formalisms.
        
    - Offers a rich set of tools for proof development and automation.
        
    - Includes the Isabelle Archive of Formal Proofs (AFP) for sharing verified theories.
        
- **Use Cases**: Formal verification of software and hardware systems, mathematical theorem proving, and education in formal methods.
    
- **Website**: [isabelle.in.tum.de](https://isabelle.in.tum.de/) ([Wikipedia](https://en.wikipedia.org/wiki/Isabelle_%28proof_assistant%29?utm_source=chatgpt.com "Isabelle (proof assistant)"))
    

### 3. **KeY**

- **Overview**: KeY is a formal verification tool tailored for Java programs. It uses dynamic logic to specify and verify program properties, allowing for both interactive and automated proofs.
    
- **Key Features**:
    
    - Integrates with Java Modeling Language (JML) for specifying program behavior.
        
    - Supports verification of Java programs through symbolic execution and deductive reasoning.
        
    - Provides a user-friendly interface for proof construction and analysis.
        
- **Use Cases**: Verification of Java applications, ensuring compliance with specifications, and detecting potential bugs or security vulnerabilities.
    
- **Website**: [key-project.org](https://www.key-project.org/) ([Wikipedia](https://en.wikipedia.org/wiki/KeY?utm_source=chatgpt.com "KeY"))
    

### 4. **Z3**

- **Overview**: Z3 is a high-performance theorem prover developed by Microsoft Research. It is used for checking the satisfiability of logical formulas and is widely employed in software verification and analysis.
    
- **Key Features**:
    
    - Supports various theories, including arithmetic, bit-vectors, arrays, and more.
        
    - Provides APIs for multiple programming languages, facilitating integration into different tools.
        
    - Efficiently handles large and complex verification problems.
        
- **Use Cases**: Static analysis, formal verification, constraint solving, and symbolic execution in software development.
    
- **Website**: [github.com/Z3Prover/z3](https://github.com/Z3Prover/z3) ([Wikipedia](https://en.wikipedia.org/wiki/Z3_Theorem_Prover?utm_source=chatgpt.com "Z3 Theorem Prover"), [arXiv](https://arxiv.org/abs/1907.03890?utm_source=chatgpt.com "Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts"))
    

### 5. **Frama-C with Jessie Plugin**

- **Overview**: Frama-C is a static analysis framework for C programs. The Jessie plugin within Frama-C allows for deductive verification using formal specifications and theorem proving.
    
- **Key Features**:
    
    - Supports the ANSI/ISO C Specification Language (ACSL) for annotating C code.
        
    - Integrates with various theorem provers like Coq, Z3, and Alt-Ergo for verifying proof obligations.
        
    - Provides a modular architecture with multiple analysis plugins.
        
- **Use Cases**: Formal verification of safety-critical C programs, ensuring adherence to specifications, and detecting potential runtime errors.
    
- **Website**: [frama-c.com](https://frama-c.com/) ([Wikipedia](https://en.wikipedia.org/wiki/Frama-C?utm_source=chatgpt.com "Frama-C"))
    
